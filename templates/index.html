<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon" />
    <title>Zeus</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: dark light;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: #0c0c0c;
        color: #f2f2f2;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding: 3rem 1.5rem;
      }

      .layout {
        display: flex;
        flex-direction: column;
        gap: 2rem;
        width: min(1100px, 100%);
      }

      main {
        width: 100%;
        max-width: 720px;
        padding: 2.5rem;
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.04);
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(12px);
      }

      h1 {
        margin-top: 0;
        font-size: 2.5rem;
        letter-spacing: 0.02em;
      }

      p.lead {
        margin-bottom: 2rem;
        color: rgba(255, 255, 255, 0.7);
      }

      form {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-weight: 600;
        letter-spacing: 0.01em;
        color: rgba(255, 255, 255, 0.85);
      }

      textarea {
        min-height: 140px;
        resize: vertical;
        padding: 1rem;
        font-size: 1rem;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(255, 255, 255, 0.05);
        color: inherit;
      }

      textarea:focus-visible {
        outline: 2px solid #5b8cff;
        outline-offset: 2px;
      }

      button {
        cursor: pointer;
        padding: 0.9rem 1.2rem;
        font-size: 1rem;
        border-radius: 999px;
        border: none;
        margin-top: 0.5rem;
        background: linear-gradient(135deg, #5b8cff, #9a5bff);
        color: white;
        transition: opacity 120ms ease;
      }

      button:disabled {
        opacity: 0.45;
        cursor: wait;
      }

      .model-status-message {
        margin: 0;
        font-size: 0.9rem;
        color: #ffb347;
        display: none;
      }

      .model-status-message.visible {
        display: block;
      }

      .status {
        margin-top: 2rem;
        display: none;
        flex-direction: column;
        gap: 0.75rem;
      }

      .status.visible {
        display: flex;
      }

      .progress-bar {
        height: 10px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.12);
        overflow: hidden;
      }

      .progress-bar span {
        display: block;
        height: 100%;
        width: 0%;
        background: linear-gradient(135deg, #5b8cff, #9a5bff);
        transition: width 180ms ease;
      }

      .player {
        margin-top: 1.5rem;
        display: none;
        flex-direction: column;
        gap: 0.75rem;
      }

      .player.visible {
        display: flex;
      }

      .player video {
        width: 100%;
        max-height: 360px;
        border-radius: 16px;
        background: #000;
      }

      .error {
        color: #ff6b6b;
      }

      .history {
        flex: 0 0 300px;
        width: 100%;
        padding: 1.75rem;
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.04);
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.24);
        backdrop-filter: blur(12px);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .history h2 {
        margin: 0;
        font-size: 1.35rem;
        letter-spacing: 0.015em;
      }

      .history-empty {
        margin: 0;
        color: rgba(255, 255, 255, 0.55);
        font-size: 0.95rem;
      }

      .history-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        overflow-y: auto;
        max-height: 60vh;
        padding-right: 0.25rem;
      }

      .history-item {
        padding: 1rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05);
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
      }

      .history-prompt {
        margin: 0;
        font-size: 0.95rem;
        line-height: 1.35;
      }

      .history-meta {
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.5);
      }

      .player-actions {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .primary,
      .history-play,
      .secondary {
        cursor: pointer;
      }

      .history-play {
        align-self: flex-start;
        padding: 0.45rem 0.9rem;
        font-size: 0.85rem;
        border-radius: 999px;
        background: rgba(91, 140, 255, 0.16);
        border: 1px solid rgba(91, 140, 255, 0.45);
        color: inherit;
        cursor: pointer;
        transition: transform 120ms ease, background 120ms ease;
      }

      .history-play:hover,
      .history-play:focus-visible {
        background: rgba(91, 140, 255, 0.3);
        transform: translateY(-1px);
      }

      .secondary {
        padding: 0.6rem 1rem;
        font-size: 0.9rem;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.08);
        color: inherit;
      }

      .secondary:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }

      .secondary:hover,
      .secondary:focus-visible {
        background: rgba(255, 255, 255, 0.12);
      }

      @media (min-width: 920px) {
        .layout {
          flex-direction: row;
          align-items: stretch;
        }

        .layout main {
          flex: 1 1 0%;
        }

        .history {
          max-height: none;
        }
      }

      @media (max-width: 919px) {
        body {
          padding: 2.5rem 1.25rem;
        }

        main {
          padding: 2rem;
        }

        .history {
          flex: 1 1 auto;
          padding: 1.5rem;
        }

        .history-list {
          max-height: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <main>
        <h1>Zeus</h1>
        <p class="lead">Welcome Voltage Park! Describe the shot you want and let the ltxv-2b-0.9.6 (dev) model bring it to life.</p>
        <form id="prompt-form">
          <label for="prompt">
            Prompt
            <textarea id="prompt" name="prompt" placeholder="A cinematic drone shot over neon-lit mountains at dusk"></textarea>
          </label>
          <button type="submit">Generate</button>
          <p id="model-status-message" class="model-status-message" role="status" aria-live="polite"></p>
        </form>

        <section id="status" class="status" aria-live="polite">
          <div id="status-text" aria-atomic="true">Idle</div>
          <div class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100">
            <span id="progress-fill"></span>
          </div>
        </section>

        <section id="player" class="player">
          <video id="result-video" controls playsinline></video>
          <div class="player-actions">
            <button id="download-btn" class="secondary" type="button" disabled>Download</button>
          </div>
        </section>
      </main>

      <aside class="history" aria-label="Past generations">
        <h2>Past Generations</h2>
        <p id="history-empty" class="history-empty">No saved videos yet. Generate one to build your library.</p>
        <ul id="history-list" class="history-list" aria-live="polite"></ul>
      </aside>
    </div>

    <script>
      const form = document.getElementById("prompt-form");
      const promptInput = document.getElementById("prompt");
      const button = form.querySelector("button");
      const statusSection = document.getElementById("status");
      const statusText = document.getElementById("status-text");
      const progressFill = document.getElementById("progress-fill");
      const progressBar = statusSection.querySelector(".progress-bar");
      const player = document.getElementById("player");
      const resultVideo = document.getElementById("result-video");
      const downloadBtn = document.getElementById("download-btn");
      const historyList = document.getElementById("history-list");
      const historyEmptyState = document.getElementById("history-empty");
      const serverStatusMessage = document.getElementById("model-status-message");
      const HISTORY_STORAGE_KEY = "zeus-history";
      const DB_NAME = "zeus-video-cache";
      const DB_STORE = "videos";

      let pollTimer = null;
      let activeJobId = null;
      let lastSubmittedPrompt = "";
      let historyEntries = [];
      let videoCache = new Map();
      let cachedVideoIds = new Set();
      let dbPromise = null;
      let currentJobId = null;
      let serverReady = false;
      let serverStatusTimer = null;
      const jobMeta = new Map();

      function resolveHandler(...values) {
        for (const value of values) {
          if (typeof value === "string" && value && value !== "unknown") {
            return value;
          }
        }
        return "";
      }

      function formatStatus(message, ...handlers) {
        const handler = resolveHandler(...handlers);
        return handler ? `${message} • served by ${handler}` : message;
      }

      function supportsLocalStorage() {
        return "localStorage" in window;
      }

      function readJsonStorage(key, fallback) {
        if (!supportsLocalStorage()) {
          return fallback;
        }

        try {
          const raw = window.localStorage.getItem(key);
          if (!raw) {
            return fallback;
          }

          const parsed = JSON.parse(raw);
          return parsed ?? fallback;
        } catch {
          return fallback;
        }
      }

      function writeJsonStorage(key, value) {
        if (!supportsLocalStorage()) {
          return;
        }

        try {
          window.localStorage.setItem(key, JSON.stringify(value));
        } catch {
          // Ignore storage errors (e.g. quota exceeded)
        }
      }

      function getJobHandler(jobId) {
        if (!jobId || !jobMeta.has(jobId)) {
          return "";
        }

        return resolveHandler(jobMeta.get(jobId)?.handledBy);
      }

      initializeHistory();
      startServerStatusWatcher();
      syncCachedVideoIds();

      if (historyList) {
        historyList.addEventListener("click", (event) => {
          const trigger = event.target.closest("button[data-job-id]");
          if (!trigger) {
            return;
          }

          const { jobId = "" } = trigger.dataset;
          const prompt = trigger.dataset.prompt ?? "";
          if (trigger.dataset.action === "download") {
            downloadCachedVideo(jobId);
          } else {
            handleHistoryReplay(jobId, prompt);
          }
        });
      }

      if (downloadBtn) {
        downloadBtn.addEventListener("click", () => {
          const jobId = downloadBtn.dataset.jobId || currentJobId;
          if (!jobId) {
            return;
          }
          downloadCachedVideo(jobId);
        });
      }

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (!serverReady) {
          statusSection.classList.add("visible");
          updateStatus("Server is building. Please wait before generating.", null, true);
          return;
        }

        clearPoll();
        clearActiveVideo();
        statusSection.classList.add("visible");

        const prompt = promptInput.value.trim();
        if (!prompt) {
          updateStatus("Please enter a prompt.", null, true);
          return;
        }
        lastSubmittedPrompt = prompt;
        updateStatus("queued", 0);

        setLoading(true);

        try {
          const res = await fetch("/api/generate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ prompt }),
          });

          if (!res.ok) {
            const payload = await safeJson(res);
            throw new Error(payload?.error ?? `Request failed (${res.status})`);
          }

          const { job_id: jobId, handled_by: handledBy } = await res.json();
          activeJobId = jobId;
          const handler = resolveHandler(handledBy);
          if (handler) {
            jobMeta.set(jobId, { handledBy: handler });
          } else {
            jobMeta.delete(jobId);
          }
          updateStatus(formatStatus("queued", handler), 0);
          pollTimer = window.setInterval(() => pollStatus(jobId), 3000);
        } catch (err) {
          updateStatus(err.message || "Failed to start generation.", null, true);
          setLoading(false);
        }
      });

      function setLoading(isLoading) {
        button.disabled = isLoading || !serverReady;
        promptInput.disabled = isLoading;
      }

      function updateStatus(message, percent, isError = false) {
        statusSection.classList.add("visible");
        statusText.textContent = message;

        if (isError || percent == null) {
          progressBar.style.display = "none";
        } else {
          progressBar.style.display = "block";
          progressFill.style.width = `${percent}%`;
          progressBar.setAttribute("aria-valuenow", percent);
        }

        statusText.classList.toggle("error", isError);
      }

      async function pollStatus(jobId) {
        try {
          const res = await fetch(`/api/jobs/${jobId}`);
          if (!res.ok) {
            const payload = await safeJson(res);
            throw new Error(payload?.error ?? `Status check failed (${res.status})`);
          }

          const { status, percent_complete: percent, handled_by: handledBy } = await res.json();
          const candidateHandler = resolveHandler(handledBy, getJobHandler(jobId));
          if (candidateHandler) {
            jobMeta.set(jobId, { handledBy: candidateHandler });
          } else if (handledBy === "unknown") {
            jobMeta.delete(jobId);
          }

          const handler = candidateHandler;

          if (status === "completed") {
            const statusMessage = formatStatus("completed", handler);
            await loadVideo(jobId, { statusMessage });
            registerHistory(jobId, lastSubmittedPrompt, handler);
            clearPoll();
            setLoading(false);
            jobMeta.delete(jobId);
            return;
          }

          if (status === "failed") {
            clearPoll();
            setLoading(false);
            jobMeta.delete(jobId);
          }

          updateStatus(formatStatus(status, handler), percent ?? null);
        } catch (err) {
          clearPoll();
          setLoading(false);
          updateStatus(err.message || "Lost connection while polling.", null, true);
        }
      }

      async function loadVideo(jobId, { fromCache = false, statusMessage = null } = {}) {
        try {
          let entry = videoCache.get(jobId);
          let blobUrl = entry?.url;

          if (!blobUrl) {
            let blob = null;
            if (fromCache) {
              blob = await loadVideoBlob(jobId);
              if (!blob) {
                throw new Error("Video not available offline.");
              }
              blobUrl = await storeVideo(jobId, blob, { skipDb: true });
            } else {
              blob = await fetchVideo(jobId);
              if (!blob) {
                throw new Error("Video unavailable.");
              }
              blobUrl = await storeVideo(jobId, blob);
            }
          }

          setActiveVideo(jobId, blobUrl);
          updateStatus(statusMessage || "completed", 100);
        } catch (err) {
          updateStatus(err.message || "Failed to load generated video.", null, true);
        }
      }

      function clearPoll() {
        if (pollTimer) {
          window.clearInterval(pollTimer);
          pollTimer = null;
        }
      }

      function startServerStatusWatcher() {
        refreshServerStatus();
        if (serverStatusTimer) {
          window.clearInterval(serverStatusTimer);
        }
        serverStatusTimer = window.setInterval(refreshServerStatus, 8000);
      }

      async function refreshServerStatus() {
        try {
          const res = await fetch("/api/model-status");
          if (!res.ok) {
            throw new Error(`Status request failed (${res.status})`);
          }
          const data = await safeJson(res) ?? {};
          updateServerReadyState(data);
          if (data.ready && serverStatusTimer) {
            window.clearInterval(serverStatusTimer);
            serverStatusTimer = null;
          }
        } catch (err) {
          updateServerReadyState({ ready: false, message: err.message || "Server status unavailable." });
        }
      }

      function updateServerReadyState(status) {
        serverReady = status?.ready === true;
        const message = status?.message || (serverReady ? "" : "Server is unavailable.");

        if (serverStatusMessage) {
          if (serverReady) {
            serverStatusMessage.textContent = "";
            serverStatusMessage.classList.remove("visible");
          } else {
            serverStatusMessage.textContent = message;
            serverStatusMessage.classList.add("visible");
          }
        }

        if (button) {
          button.title = serverReady ? "" : message;
        }

        if (!button.disabled || serverReady) {
          setLoading(false);
        } else {
          button.disabled = true;
        }
      }

      function initializeHistory() {
        historyEntries = loadStoredHistory();
        cachedVideoIds = new Set();
        renderHistory();
      }

      function handleHistoryReplay(jobId, prompt) {
        if (!jobId) {
          return;
        }

        clearPoll();
        activeJobId = null;
        statusSection.classList.add("visible");
        updateStatus("Loading saved video...", null);

        if (prompt) {
          promptInput.value = prompt;
        }

        clearActiveVideo();
        setLoading(true);
        const entry = historyEntries.find((item) => item.jobId === jobId);
        const statusMessage = formatStatus("completed", entry?.handledBy, entry?.servedBy);
        loadVideo(jobId, {
          fromCache: true,
          statusMessage,
        }).finally(() => {
          setLoading(false);
        });
      }

      function registerHistory(jobId, prompt, handledBy) {
        if (!jobId || !prompt) {
          return;
        }

        const deduped = historyEntries.filter((entry) => entry.jobId !== jobId);
        const entry = {
          jobId,
          prompt,
          createdAt: Date.now(),
        };
        if (handledBy && handledBy !== "unknown") {
          entry.handledBy = handledBy;
        }
        historyEntries = [
          entry,
          ...deduped,
        ].slice(0, 10);

        saveHistory();
        pruneCachedVideos();
        renderHistory();
      }

      function renderHistory() {
        if (!historyList || !historyEmptyState) {
          return;
        }

        historyList.innerHTML = "";

        if (historyEntries.length === 0) {
          historyEmptyState.style.display = "block";
          return;
        }

        historyEmptyState.style.display = "none";

        historyEntries.forEach((entry) => {
          const item = document.createElement("li");
          item.className = "history-item";

          const promptEl = document.createElement("p");
          promptEl.className = "history-prompt";
          promptEl.textContent = entry.prompt;
          item.appendChild(promptEl);

          const timestamp = formatTimestamp(entry.createdAt);
          const details = [];
          if (timestamp) {
            details.push(timestamp);
          }
          const handler = resolveHandler(entry.handledBy, entry.servedBy);
          if (handler && handler !== "unknown") {
            details.push(`Served by ${handler}`);
          }
          if (details.length > 0) {
            const meta = document.createElement("div");
            meta.className = "history-meta";
            meta.textContent = details.join(" • ");
            item.appendChild(meta);
          }

          const action = document.createElement("button");
          action.type = "button";
          action.className = "history-play";
          action.dataset.jobId = entry.jobId;
          action.dataset.prompt = entry.prompt;
          action.textContent = "Play";
          item.appendChild(action);

          if (hasCachedVideo(entry.jobId)) {
            const download = document.createElement("button");
            download.type = "button";
            download.className = "history-play";
            download.dataset.jobId = entry.jobId;
            download.dataset.prompt = entry.prompt;
            download.dataset.action = "download";
            download.textContent = "Download";
            item.appendChild(download);
          }

          historyList.appendChild(item);
        });
      }

    async function fetchVideo(jobId) {
      const res = await fetch(`/generated/${jobId}/out.mp4`);
      if (!res.ok) {
        return null;
      }
      return res.blob();
    }

    async function storeVideo(jobId, blob, { skipDb = false } = {}) {
      if (!blob) {
        return null;
      }

      const previous = videoCache.get(jobId);
      if (previous?.url) {
        URL.revokeObjectURL(previous.url);
      }

      const url = URL.createObjectURL(blob);
      videoCache.set(jobId, { url, size: blob.size ?? 0 });
      cachedVideoIds.add(jobId);

      if (!skipDb) {
        try {
          await saveVideoBlob(jobId, blob);
        } catch (err) {
          console.warn("Failed to persist video locally", err);
        }
      }

      return url;
    }

    function pruneCachedVideos() {
      const validIds = new Set(historyEntries.map((entry) => entry.jobId));

      videoCache.forEach((value, key) => {
        if (!validIds.has(key)) {
          if (value?.url) {
            try {
              URL.revokeObjectURL(value.url);
            } catch {
              // ignore
            }
          }
          videoCache.delete(key);
        }
      });

      cachedVideoIds = new Set(Array.from(cachedVideoIds).filter((id) => validIds.has(id)));
      cleanupVideoStorage(validIds);
    }

    function setActiveVideo(jobId, url) {
      if (!url) {
        return;
      }

      currentJobId = jobId;
      player.classList.add("visible");
      resultVideo.src = url;
      resultVideo.classList.add("visible");
      if (downloadBtn) {
        downloadBtn.disabled = false;
        downloadBtn.dataset.jobId = jobId;
      }
      resultVideo.currentTime = 0;
      resultVideo.play().catch(() => {});
    }

    function clearActiveVideo() {
      if (player) {
        player.classList.remove("visible");
      }
      resultVideo.pause();
      resultVideo.removeAttribute("src");
      resultVideo.classList.remove("visible");
      resultVideo.load();
      if (downloadBtn) {
        downloadBtn.disabled = true;
        delete downloadBtn.dataset.jobId;
      }
      currentJobId = null;
    }

    async function downloadCachedVideo(jobId) {
      if (!jobId) {
        return;
      }

      try {
        let url = videoCache.get(jobId)?.url;
        if (!url) {
          const blob = await loadVideoBlob(jobId);
          if (!blob) {
            updateStatus("Video not available offline.", null, true);
            return;
          }
          url = await storeVideo(jobId, blob, { skipDb: true });
        }

        triggerDownload(jobId, url);
      } catch (err) {
        updateStatus((err && err.message) || "Unable to download video.", null, true);
      }
    }

    function triggerDownload(jobId, url) {
      const anchor = document.createElement("a");
      anchor.href = url;
      anchor.download = `zeus-${jobId}.mp4`;
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
    }

    function hasCachedVideo(jobId) {
      return videoCache.has(jobId) || cachedVideoIds.has(jobId);
    }

    async function getVideoDb() {
      if (!("indexedDB" in window)) {
        return null;
      }

      if (!dbPromise) {
        dbPromise = new Promise((resolve, reject) => {
          const open = indexedDB.open(DB_NAME, 1);
          open.onupgradeneeded = () => {
            open.result.createObjectStore(DB_STORE);
          };
          open.onsuccess = () => resolve(open.result);
          open.onerror = () => reject(open.error ?? new Error("indexedDB open failed"));
        });
      }

      return dbPromise;
    }

    async function saveVideoBlob(jobId, blob) {
      const db = await getVideoDb();
      if (!db) {
        return;
      }

      await new Promise((resolve, reject) => {
        const tx = db.transaction(DB_STORE, "readwrite");
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error ?? new Error("Failed to store video"));
        tx.objectStore(DB_STORE).put(blob, jobId);
      });
    }

    async function loadVideoBlob(jobId) {
      const db = await getVideoDb();
      if (!db) {
        return null;
      }

      return new Promise((resolve, reject) => {
        const tx = db.transaction(DB_STORE, "readonly");
        const request = tx.objectStore(DB_STORE).get(jobId);
        request.onsuccess = () => resolve(request.result ?? null);
        request.onerror = () => reject(request.error ?? new Error("Failed to load cached video"));
      });
    }

    async function syncCachedVideoIds() {
      try {
        const ids = await listStoredVideoIds();
        cachedVideoIds = new Set(
          ids.filter((id) => typeof id === "string" && id.length > 0)
        );
        renderHistory();
      } catch (err) {
        console.warn("Failed to load cached video ids", err);
      }
    }

    async function listStoredVideoIds(dbInstance = null) {
      const db = dbInstance ?? (await getVideoDb());
      if (!db) {
        return [];
      }

      return new Promise((resolve, reject) => {
        const tx = db.transaction(DB_STORE, "readonly");
        const store = tx.objectStore(DB_STORE);

        if (typeof store.getAllKeys === "function") {
          const request = store.getAllKeys();
          request.onsuccess = () => resolve(request.result ?? []);
          request.onerror = () =>
            reject(request.error ?? new Error("Failed to read cached video ids"));
          return;
        }

        const ids = [];
        const request = store.openCursor();
        request.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            ids.push(cursor.key);
            cursor.continue();
          } else {
            resolve(ids);
          }
        };
        request.onerror = () =>
          reject(request.error ?? new Error("Failed to read cached video ids"));
      });
    }

    async function cleanupVideoStorage(validIds) {
      try {
        const db = await getVideoDb();
        if (!db) {
          return;
        }

        const ids = await listStoredVideoIds(db);
        const staleIds = ids.filter((id) => !validIds.has(id));
        if (staleIds.length === 0) {
          return;
        }

        await new Promise((resolve, reject) => {
          const tx = db.transaction(DB_STORE, "readwrite");
          const store = tx.objectStore(DB_STORE);

          staleIds.forEach((id) => {
            try {
              store.delete(id);
            } catch (error) {
              console.warn(`Failed to schedule deletion for video ${id}`, error);
            }
          });

          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error ?? new Error("Failed to prune video cache"));
        });
      } catch (err) {
        console.warn("Failed to prune persisted video cache", err);
      }
    }

    function loadStoredHistory() {
      const stored = readJsonStorage(HISTORY_STORAGE_KEY, []);
      if (!Array.isArray(stored)) {
        return [];
      }

      return stored
        .filter(
          (entry) =>
            entry &&
            typeof entry === "object" &&
            typeof entry.jobId === "string" &&
            entry.jobId.length > 0 &&
            typeof entry.prompt === "string"
        )
        .map((entry) => {
          const base = {
            jobId: entry.jobId,
            prompt: entry.prompt,
            createdAt: typeof entry.createdAt === "number" ? entry.createdAt : Date.now(),
          };
          const handledBy = resolveHandler(entry.handledBy, entry.servedBy, entry.handled_by);
          if (handledBy) {
            base.handledBy = handledBy;
          }
          return base;
        });
    }

      function saveHistory() {
        writeJsonStorage(HISTORY_STORAGE_KEY, historyEntries);
      }

      function formatTimestamp(value) {
        if (!value) {
          return "";
        }

        try {
          const date = new Date(value);
          if (Number.isNaN(date.getTime())) {
            return "";
          }
          return date.toLocaleString();
        } catch {
          return "";
        }
      }

      async function safeJson(response) {
        try {
          return await response.json();
        } catch {
          return null;
        }
      }

      window.addEventListener("beforeunload", () => {
        if (activeJobId) {
          clearPoll();
        }
        if (serverStatusTimer) {
          window.clearInterval(serverStatusTimer);
        }
      });
    </script>
  </body>
</html>
