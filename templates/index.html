<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon" />
    <title>Zeus</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: dark light;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: #0c0c0c;
        color: #f2f2f2;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding: 3rem 1.5rem;
      }

      .layout {
        display: flex;
        flex-direction: column;
        gap: 2rem;
        width: min(1100px, 100%);
      }

      main {
        width: 100%;
        max-width: 720px;
        padding: 2.5rem;
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.04);
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(12px);
      }

      h1 {
        margin-top: 0;
        font-size: 2.5rem;
        letter-spacing: 0.02em;
      }

      p.lead {
        margin-bottom: 2rem;
        color: rgba(255, 255, 255, 0.7);
      }

      form {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-weight: 600;
        letter-spacing: 0.01em;
        color: rgba(255, 255, 255, 0.85);
      }

      textarea {
        min-height: 140px;
        resize: vertical;
        padding: 1rem;
        font-size: 1rem;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(255, 255, 255, 0.05);
        color: inherit;
      }

      textarea:focus-visible {
        outline: 2px solid #5b8cff;
        outline-offset: 2px;
      }

      button {
        cursor: pointer;
        padding: 0.9rem 1.2rem;
        font-size: 1rem;
        border-radius: 999px;
        border: none;
        margin-top: 0.5rem;
        background: linear-gradient(135deg, #5b8cff, #9a5bff);
        color: white;
        transition: opacity 120ms ease;
      }

      button:disabled {
        opacity: 0.45;
        cursor: wait;
      }

      .model-status-message {
        margin: 0;
        font-size: 0.9rem;
        color: #ffb347;
        display: none;
      }

      .model-status-message.visible {
        display: block;
      }

      .status {
        margin-top: 2rem;
        display: none;
        flex-direction: column;
        gap: 0.75rem;
      }

      .status.visible {
        display: flex;
      }

      .progress-bar {
        height: 10px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.12);
        overflow: hidden;
      }

      .progress-bar span {
        display: block;
        height: 100%;
        width: 0%;
        background: linear-gradient(135deg, #5b8cff, #9a5bff);
        transition: width 180ms ease;
      }

      .player {
        margin-top: 1.5rem;
        display: none;
        flex-direction: column;
        gap: 0.75rem;
      }

      .player.visible {
        display: flex;
      }

      .player video {
        width: 100%;
        max-height: 360px;
        border-radius: 16px;
        background: #000;
      }

      .error {
        color: #ff6b6b;
      }

      .history {
        flex: 0 0 300px;
        width: 100%;
        padding: 1.75rem;
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.04);
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.24);
        backdrop-filter: blur(12px);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .history h2 {
        margin: 0;
        font-size: 1.35rem;
        letter-spacing: 0.015em;
      }

      .history-empty {
        margin: 0;
        color: rgba(255, 255, 255, 0.55);
        font-size: 0.95rem;
      }

      .history-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        overflow-y: auto;
        max-height: 60vh;
        padding-right: 0.25rem;
      }

      .history-item {
        padding: 1rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05);
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
      }

      .history-prompt {
        margin: 0;
        font-size: 0.95rem;
        line-height: 1.35;
      }

      .history-meta {
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.5);
      }

      .player-actions {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .primary,
      .history-play,
      .secondary {
        cursor: pointer;
      }

      .history-play {
        align-self: flex-start;
        padding: 0.45rem 0.9rem;
        font-size: 0.85rem;
        border-radius: 999px;
        background: rgba(91, 140, 255, 0.16);
        border: 1px solid rgba(91, 140, 255, 0.45);
        color: inherit;
        cursor: pointer;
        transition: transform 120ms ease, background 120ms ease;
      }

      .history-play:hover,
      .history-play:focus-visible {
        background: rgba(91, 140, 255, 0.3);
        transform: translateY(-1px);
      }

      .secondary {
        padding: 0.6rem 1rem;
        font-size: 0.9rem;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.08);
        color: inherit;
      }

      .secondary:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }

      .secondary:hover,
      .secondary:focus-visible {
        background: rgba(255, 255, 255, 0.12);
      }

      @media (min-width: 920px) {
        .layout {
          flex-direction: row;
          align-items: stretch;
        }

        .layout main {
          flex: 1 1 0%;
        }

        .history {
          max-height: none;
        }
      }

      @media (max-width: 919px) {
        body {
          padding: 2.5rem 1.25rem;
        }

        main {
          padding: 2rem;
        }

        .history {
          flex: 1 1 auto;
          padding: 1.5rem;
        }

        .history-list {
          max-height: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <main>
        <h1>Zeus</h1>
        <p class="lead">Welcome Voltage Park! Describe the shot you want and let the LTX-Video model bring it to life.</p>
        <form id="prompt-form">
          <label for="prompt">
            Prompt
            <textarea id="prompt" name="prompt" placeholder="A cinematic drone shot over neon-lit mountains at dusk"></textarea>
          </label>
          <button type="submit">Generate</button>
          <p id="model-status-message" class="model-status-message" role="status" aria-live="polite"></p>
        </form>

        <section id="status" class="status" aria-live="polite">
          <div id="status-text" aria-atomic="true">Idle</div>
          <div class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100">
            <span id="progress-fill"></span>
          </div>
        </section>

        <section id="player" class="player">
          <video id="result-video" controls playsinline></video>
          <div class="player-actions">
            <button id="download-btn" class="secondary" type="button" disabled>Download</button>
          </div>
        </section>
      </main>

      <aside class="history" aria-label="Past generations">
        <h2>Past Generations</h2>
        <p id="history-empty" class="history-empty">No saved videos yet. Generate one to build your library.</p>
        <ul id="history-list" class="history-list" aria-live="polite"></ul>
      </aside>
    </div>

    <script>
      const form = document.getElementById("prompt-form");
      const promptInput = document.getElementById("prompt");
      const button = form.querySelector("button");
      const statusSection = document.getElementById("status");
      const statusText = document.getElementById("status-text");
      const progressFill = document.getElementById("progress-fill");
      const progressBar = statusSection.querySelector(".progress-bar");
      const player = document.getElementById("player");
      const resultVideo = document.getElementById("result-video");
      const downloadBtn = document.getElementById("download-btn");
      const historyList = document.getElementById("history-list");
      const historyEmptyState = document.getElementById("history-empty");
      const modelStatusMessage = document.getElementById("model-status-message");
      const HISTORY_STORAGE_KEY = "zeus-history";
      const HISTORY_VIDEO_KEY = "zeus-history-videos";
      const DB_NAME = "zeus-video-cache";
      const DB_STORE = "videos";

      let pollTimer = null;
      let activeJobId = null;
      let lastSubmittedPrompt = "";
      let lastHandledBy = "";
      let historyEntries = [];
      let videoCache = new Map();
      let cachedVideoIds = new Set();
      let dbPromise = null;
      let currentJobId = null;
      let modelReady = false;
      let modelStatusTimer = null;
      const jobMeta = new Map();

      initializeHistory();
      startModelStatusWatcher();

      if (historyList) {
        historyList.addEventListener("click", (event) => {
          const trigger = event.target.closest("button[data-job-id]");
          if (!trigger) {
            return;
          }

          const { jobId = "" } = trigger.dataset;
          const prompt = trigger.dataset.prompt ?? "";
          if (trigger.dataset.action === "download") {
            downloadCachedVideo(jobId);
          } else {
            handleHistoryReplay(jobId, prompt);
          }
        });
      }

      if (downloadBtn) {
        downloadBtn.addEventListener("click", () => {
          const jobId = downloadBtn.dataset.jobId || currentJobId;
          if (!jobId) {
            return;
          }
          downloadCachedVideo(jobId);
        });
      }

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (!modelReady) {
          statusSection.classList.add("visible");
          updateStatus("Model is downloading. Please wait before generating.", null, true);
          return;
        }

        clearPoll();
        clearActiveVideo();
        statusSection.classList.add("visible");

        const prompt = promptInput.value.trim();
        if (!prompt) {
          updateStatus("Please enter a prompt.", null, true);
          return;
        }
        lastSubmittedPrompt = prompt;
        updateStatus("queued", 0);

        setLoading(true);

        try {
          const res = await fetch("/api/generate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ prompt }),
          });

          if (!res.ok) {
            const payload = await safeJson(res);
            throw new Error(payload?.error ?? `Request failed (${res.status})`);
          }

          const { job_id: jobId, handled_by: handledBy } = await res.json();
          activeJobId = jobId;
          const handler = handledBy || "unknown";
          jobMeta.set(jobId, { handledBy: handler });
          lastHandledBy = handler;
          updateStatus(`queued • served by ${handler}`, 0);
          pollTimer = window.setInterval(() => pollStatus(jobId), 1500);
        } catch (err) {
          updateStatus(err.message || "Failed to start generation.", null, true);
          setLoading(false);
        }
      });

      function setLoading(isLoading) {
        button.disabled = isLoading || !modelReady;
        promptInput.disabled = isLoading;
      }

      function updateStatus(message, percent, isError = false) {
        statusSection.classList.add("visible");
        statusText.textContent = message;

        if (isError || percent == null) {
          progressBar.style.display = "none";
        } else {
          progressBar.style.display = "block";
          progressFill.style.width = `${percent}%`;
          progressBar.setAttribute("aria-valuenow", percent);
        }

        statusText.classList.toggle("error", isError);
      }

      async function pollStatus(jobId) {
        try {
          const res = await fetch(`/api/jobs/${jobId}`);
          if (!res.ok) {
            const payload = await safeJson(res);
            throw new Error(payload?.error ?? `Status check failed (${res.status})`);
          }

          const { status, percent_complete: percent } = await res.json();

          if (status === "completed") {
            const handler = jobMeta.get(jobId)?.handledBy || lastHandledBy || "";
            const statusMessage = handler && handler !== "unknown" ? `completed • served by ${handler}` : "completed";
            await loadVideo(jobId, { statusMessage });
            registerHistory(jobId, lastSubmittedPrompt, handler);
            clearPoll();
            setLoading(false);
            jobMeta.delete(jobId);
          } else if (status === "failed") {
            clearPoll();
            setLoading(false);
          }
          if (status !== "completed") {
            updateStatus(status, percent ?? null);
          }
        } catch (err) {
          clearPoll();
          setLoading(false);
          updateStatus(err.message || "Lost connection while polling.", null, true);
        }
      }

      async function loadVideo(jobId, { fromCache = false, statusMessage = null } = {}) {
        try {
          let entry = videoCache.get(jobId);
          let blobUrl = entry?.url;

          if (!blobUrl) {
            let blob = null;
            if (fromCache) {
              blob = await loadVideoBlob(jobId);
              if (!blob) {
                throw new Error("Video not available offline.");
              }
              blobUrl = await storeVideo(jobId, blob, { skipDb: true });
            } else {
              blob = await fetchVideo(jobId);
              if (!blob) {
                throw new Error("Video unavailable.");
              }
              blobUrl = await storeVideo(jobId, blob);
            }
          }

          setActiveVideo(jobId, blobUrl);
          updateStatus(statusMessage || "completed", 100);
        } catch (err) {
          updateStatus(err.message || "Failed to load generated video.", null, true);
        }
      }

      function clearPoll() {
        if (pollTimer) {
          window.clearInterval(pollTimer);
          pollTimer = null;
        }
      }

      function startModelStatusWatcher() {
        refreshModelStatus();
        if (modelStatusTimer) {
          window.clearInterval(modelStatusTimer);
        }
        modelStatusTimer = window.setInterval(refreshModelStatus, 8000);
      }

      async function refreshModelStatus() {
        try {
          const res = await fetch("/api/model-status");
          if (!res.ok) {
            throw new Error(`Status request failed (${res.status})`);
          }
          const data = await safeJson(res) ?? {};
          updateModelReadyState(data);
          if (data.ready && modelStatusTimer) {
            window.clearInterval(modelStatusTimer);
            modelStatusTimer = null;
          }
        } catch (err) {
          updateModelReadyState({ ready: false, message: err.message || "Model status unavailable." });
        }
      }

      function updateModelReadyState(status) {
        modelReady = status?.ready === true;
        const message = status?.message || (modelReady ? "" : "Model is unavailable.");

        if (modelStatusMessage) {
          if (modelReady) {
            modelStatusMessage.textContent = "";
            modelStatusMessage.classList.remove("visible");
          } else {
            modelStatusMessage.textContent = message;
            modelStatusMessage.classList.add("visible");
          }
        }

        if (button) {
          button.title = modelReady ? "" : message;
        }

        if (!button.disabled || modelReady) {
          setLoading(false);
        } else {
          button.disabled = true;
        }
      }

      function initializeHistory() {
        historyEntries = loadStoredHistory();
        cachedVideoIds = loadStoredVideoIds();
        renderHistory();
      }

      function handleHistoryReplay(jobId, prompt) {
        if (!jobId) {
          return;
        }

        clearPoll();
        activeJobId = null;
        statusSection.classList.add("visible");
        updateStatus("Loading saved video...", null);

        if (prompt) {
          promptInput.value = prompt;
        }

        clearActiveVideo();
        setLoading(true);
        const entry = historyEntries.find((item) => item.jobId === jobId);
        const handler = entry?.handledBy || "";
        const statusMessage = handler ? `completed • served by ${handler}` : "completed";
        loadVideo(jobId, {
          fromCache: true,
          statusMessage,
        }).finally(() => {
          setLoading(false);
        });
      }

      function registerHistory(jobId, prompt, handledBy) {
        if (!jobId || !prompt) {
          return;
        }

        const deduped = historyEntries.filter((entry) => entry.jobId !== jobId);
        const entry = {
          jobId,
          prompt,
          createdAt: Date.now(),
        };
        if (handledBy && handledBy !== "unknown") {
          entry.handledBy = handledBy;
        }
        historyEntries = [
          entry,
          ...deduped,
        ].slice(0, 10);

        saveHistory();
        pruneCachedVideos();
        renderHistory();
      }

      function renderHistory() {
        if (!historyList || !historyEmptyState) {
          return;
        }

        historyList.innerHTML = "";

        if (historyEntries.length === 0) {
          historyEmptyState.style.display = "block";
          return;
        }

        historyEmptyState.style.display = "none";

        historyEntries.forEach((entry) => {
          const item = document.createElement("li");
          item.className = "history-item";

          const promptEl = document.createElement("p");
          promptEl.className = "history-prompt";
          promptEl.textContent = entry.prompt;
          item.appendChild(promptEl);

          const timestamp = formatTimestamp(entry.createdAt);
          const details = [];
          if (timestamp) {
            details.push(timestamp);
          }
          if (entry.handledBy && entry.handledBy !== "unknown") {
            details.push(`Served by ${entry.handledBy}`);
          }
          if (details.length > 0) {
            const meta = document.createElement("div");
            meta.className = "history-meta";
            meta.textContent = details.join(" • ");
            item.appendChild(meta);
          }

          const action = document.createElement("button");
          action.type = "button";
          action.className = "history-play";
          action.dataset.jobId = entry.jobId;
          action.dataset.prompt = entry.prompt;
          action.textContent = "Replay";
          item.appendChild(action);

          if (hasCachedVideo(entry.jobId)) {
            const download = document.createElement("button");
            download.type = "button";
            download.className = "history-play";
            download.dataset.jobId = entry.jobId;
            download.dataset.prompt = entry.prompt;
            download.dataset.action = "download";
            download.textContent = "Download";
            item.appendChild(download);
          }

          historyList.appendChild(item);
        });
      }

    async function fetchVideo(jobId) {
      const res = await fetch(`/files/${jobId}/out.mp4`);
      if (!res.ok) {
        return null;
      }
      return res.blob();
    }

    async function storeVideo(jobId, blob, { skipDb = false } = {}) {
      if (!blob) {
        return null;
      }

      const previous = videoCache.get(jobId);
      if (previous?.url) {
        URL.revokeObjectURL(previous.url);
      }

      const url = URL.createObjectURL(blob);
      videoCache.set(jobId, { url, size: blob.size ?? 0 });
      cachedVideoIds.add(jobId);
      saveStoredVideoIds();

      if (!skipDb) {
        try {
          await saveVideoBlob(jobId, blob);
        } catch (err) {
          console.warn("Failed to persist video locally", err);
        }
      }

      return url;
    }

    function pruneCachedVideos() {
      const validIds = new Set(historyEntries.map((entry) => entry.jobId));

      videoCache.forEach((value, key) => {
        if (!validIds.has(key)) {
          if (value?.url) {
            try {
              URL.revokeObjectURL(value.url);
            } catch {
              // ignore
            }
          }
          videoCache.delete(key);
        }
      });

      cachedVideoIds = new Set(Array.from(cachedVideoIds).filter((id) => validIds.has(id)));
      saveStoredVideoIds();
    }

    function setActiveVideo(jobId, url) {
      if (!url) {
        return;
      }

      currentJobId = jobId;
      player.classList.add("visible");
      resultVideo.src = url;
      resultVideo.classList.add("visible");
      if (downloadBtn) {
        downloadBtn.disabled = false;
        downloadBtn.dataset.jobId = jobId;
      }
      resultVideo.currentTime = 0;
      resultVideo.play().catch(() => {});
    }

    function clearActiveVideo() {
      if (player) {
        player.classList.remove("visible");
      }
      resultVideo.pause();
      resultVideo.removeAttribute("src");
      resultVideo.classList.remove("visible");
      resultVideo.load();
      if (downloadBtn) {
        downloadBtn.disabled = true;
        delete downloadBtn.dataset.jobId;
      }
      currentJobId = null;
    }

    async function downloadCachedVideo(jobId) {
      if (!jobId) {
        return;
      }

      try {
        let url = videoCache.get(jobId)?.url;
        if (!url) {
          const blob = await loadVideoBlob(jobId);
          if (!blob) {
            updateStatus("Video not available offline.", null, true);
            return;
          }
          url = await storeVideo(jobId, blob, { skipDb: true });
        }

        triggerDownload(jobId, url);
      } catch (err) {
        updateStatus((err && err.message) || "Unable to download video.", null, true);
      }
    }

    function triggerDownload(jobId, url) {
      const anchor = document.createElement("a");
      anchor.href = url;
      anchor.download = `zeus-${jobId}.mp4`;
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
    }

    function hasCachedVideo(jobId) {
      return videoCache.has(jobId) || cachedVideoIds.has(jobId);
    }

    function loadStoredVideoIds() {
      if (!("localStorage" in window)) {
        return new Set();
      }

      try {
        const raw = window.localStorage.getItem(HISTORY_VIDEO_KEY);
        if (!raw) {
          return new Set();
        }

        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) {
          return new Set();
        }

        return new Set(parsed.filter((id) => typeof id === "string" && id.length > 0));
      } catch {
        return new Set();
      }
    }

    function saveStoredVideoIds() {
      if (!("localStorage" in window)) {
        return;
      }

      try {
        window.localStorage.setItem(HISTORY_VIDEO_KEY, JSON.stringify(Array.from(cachedVideoIds)));
      } catch {
        // ignore storage errors
      }
    }

    async function getVideoDb() {
      if (!("indexedDB" in window)) {
        return null;
      }

      if (!dbPromise) {
        dbPromise = new Promise((resolve, reject) => {
          const open = indexedDB.open(DB_NAME, 1);
          open.onupgradeneeded = () => {
            open.result.createObjectStore(DB_STORE);
          };
          open.onsuccess = () => resolve(open.result);
          open.onerror = () => reject(open.error ?? new Error("indexedDB open failed"));
        });
      }

      return dbPromise;
    }

    async function saveVideoBlob(jobId, blob) {
      const db = await getVideoDb();
      if (!db) {
        return;
      }

      await new Promise((resolve, reject) => {
        const tx = db.transaction(DB_STORE, "readwrite");
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error ?? new Error("Failed to store video"));
        tx.objectStore(DB_STORE).put(blob, jobId);
      });
    }

    async function loadVideoBlob(jobId) {
      const db = await getVideoDb();
      if (!db) {
        return null;
      }

      return new Promise((resolve, reject) => {
        const tx = db.transaction(DB_STORE, "readonly");
        const request = tx.objectStore(DB_STORE).get(jobId);
        request.onsuccess = () => resolve(request.result ?? null);
        request.onerror = () => reject(request.error ?? new Error("Failed to load cached video"));
      });
    }

    function loadStoredHistory() {
      if (!("localStorage" in window)) {
        return [];
      }

      try {
        const raw = window.localStorage.getItem(HISTORY_STORAGE_KEY);
        if (!raw) {
          return [];
        }

        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) {
          return [];
        }

        return parsed
          .filter(
            (entry) =>
              entry &&
              typeof entry === "object" &&
              typeof entry.jobId === "string" &&
              entry.jobId.length > 0 &&
              typeof entry.prompt === "string"
          )
          .map((entry) => {
            const base = {
              jobId: entry.jobId,
              prompt: entry.prompt,
              createdAt: typeof entry.createdAt === "number" ? entry.createdAt : Date.now(),
            };
            const handledBy =
              typeof entry.handledBy === "string"
                ? entry.handledBy
                : typeof entry.handled_by === "string"
                ? entry.handled_by
                : undefined;
            if (handledBy && handledBy !== "unknown") {
              base.handledBy = handledBy;
            }
            return base;
          });
      } catch {
        return [];
      }
    }

      function saveHistory() {
        if (!("localStorage" in window)) {
          return;
        }

        try {
          window.localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(historyEntries));
        } catch {
          // Ignore storage errors (e.g. quota exceeded)
        }
      }

      function formatTimestamp(value) {
        if (!value) {
          return "";
        }

        try {
          const date = new Date(value);
          if (Number.isNaN(date.getTime())) {
            return "";
          }
          return date.toLocaleString();
        } catch {
          return "";
        }
      }

      async function safeJson(response) {
        try {
          return await response.json();
        } catch {
          return null;
        }
      }

      window.addEventListener("beforeunload", () => {
        if (activeJobId) {
          clearPoll();
        }
        if (modelStatusTimer) {
          window.clearInterval(modelStatusTimer);
        }
      });
    </script>
  </body>
</html>
